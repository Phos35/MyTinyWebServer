# 操作系统

1. 进程、线程、协程是什么？

   > 1. 进程：进程是程序的运行实例，由程序、数据、进程控制块组成
   > 2. 线程：轻量级进程，是进程中更微小的执行单元。由线程id，程序计数器、寄存器和堆栈组成
   > 3. 协程：用户空间线程，调度完全由用户/程序决定

2. 进程和线程之间的区别

   > 1. 单位性
   > 2. 归属关系
   > 3. 资源共享
   > 4. 调度切换

3. 线程和协程之间的区别

   > 1. 资源占用
   > 2. 由谁调度
   > 3. 切换开销：线程的切换需要用户态、内核态的切换和寄存器等的刷新，而协程只需要修改很少数量的寄存器值
   > 4. 性能
   > 5. 数据同步

4. 怎么创建使用线程

   > 1. pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (\*routine)(void*), void* args)
   > 2. std::thread(func, args)
   
5. 死锁发生的条件[^1]

   > 1. 互斥条件：一个资源每次只能被一个进程使用
   > 2. 请求保持条件：进程因请求新资源而阻塞时，对已获得的资源保持不放
   > 3. 不可剥夺条件：进程已获得的资源，在使用完成前，不能强行剥夺
   > 4. 循环等待：若干个进程之间形成头尾相接的资源等待关系

6. 处理死锁的四种方法[^1]

   > 1. 死锁预防：破环死锁必要条件中的一个，使得死锁无法发生
   > 2. 死锁检测：允许死锁发生，但需要添加检测模块及时检测死锁并加以处理
   > 3. 死锁避免：在资源分配的过程中，使用特定方法避免系统进入不安全状态
   > 4. 死锁解除：当检测到死锁发生时，将进程从死锁状态中解脱出来

7. 如何检测死锁[^2]

   > 1. 每种类型一个资源：有向图有环则为死锁
   > 2. 每种类型多个资源：资源矩阵计算判断

8. 如何避免死锁[^1]

   > 1. 进程启动拒绝：若进程的资源请求中存在会导致思索的，则不启动进程
   > 2. 资源分配拒绝：若进程新增的资源请求会导致死锁，则不允许分配该资源 —— 银行家算法

9. 如何解除死锁

   > 1. 资源剥夺法：剥夺陷入死锁的部分进程的资源，分配给其它死锁进程，解除死锁
   > 2. 进程撤销法：撤销陷入死锁的部分或全部进程，释放资源

10. 银行家算法[^2]

    > 1. 安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。
    > 2. 详细算法详见链接4
    
11. 并行和并发

    >1. 总的概括：并行是时刻上的共同执行，并发是一段时间范围内的共同执行
    >2. 并行：需要多CPU才能实现，多个CPU可以同时执行
    >3. 并发：在单CPU上就可以通过调度来实现

12. 进程间通信方式

    > 1. 匿名管道
    > 2. 命名管道
    > 3. 消息队列
    > 4. 共享内存
    > 5. 信号
    > 6. 信号量
    > 7. Socket



[^1]:[死锁四个必要条件及死锁的预防、检测、避免、解除](https://blog.csdn.net/hj605635529/article/details/69214903)
[^2]:[计算机操作系统 - 死锁](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md#2-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B)