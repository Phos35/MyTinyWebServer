# 数据结构

1. 哈希 哈希冲突

   >1. 哈希：对于输入I，我们通过函数F将其转化为数值D，我们以数值D为输入I的索引值进行存储。这种方法被称之为哈希
   >2. 哈希冲突：不同的输入$I_1$, $I_2$通过函数F可能得到相同的值D，此时两个输入的索引值发生了冲突，我们称之为哈希冲突
   >3. 哈希冲突的解决方法
   >  1. 再散列法/开放定址法
   >     1. 通用函数
   >        $D_i = (F(I) + d_i) \% m, i = 1,2,3,,...$
   >        其中:
   >        $D_i$为第i次计算出的索引值
   >        $d_i$是一个增量序列，用于在产生冲突时计算新的哈希值
   >        $m$表长
   >     2. 线性探测再散列
   >        增量序列为自然数序列，因为$D_i$随着$d_i$线性增长，所以称之为线性探测再散列
   >     3. 二次探测再散列
   >        $d_i=1^2,-1^2,2^2,-2^2,...,k^2,-k^2 (k <= m\div2)$
   >        即计算出的$D_i$在最初的$D$值两侧跳跃式探测
   >     4. 伪随机探测再散列
   >        $d_i \in 伪随机数序列$
   >  2. 再哈希法
   >     本质为准备多个哈希函数F，当$F_1(I)$发生冲突时使用$F_2(I)$；若$F_2(i)$发生冲突，则使用$F_3(I)$...，以此类推，直至不再发生冲突为止
   >  3. 链地址法
   >     哈希表中的每个元素为链表，当哈希冲突发生时，同D值的元素添加到该位置的链表中
   >  4. 建立公共溢出区
   >     将哈希表分为基本表和溢出表两个部分，凡是与基本表冲突的元素都填入溢出表中
   >4. 解决方法的适用场景
   >  1. 开放定址法
   >     1. 优点：数据存储在数组中，访问速度快，序列化简单
   >     2. 缺点：删除操作复杂，需要使用特殊标记；冲突解决的代价比链地址法高
   >     3. 适用场景：数据量小、装载因子（关键字个数与表长度之比）小的场景
   >  2. 链地址法
   >     1. 优点：内存利用率高；装载因子容忍度高；可以将链表改为红黑树等高效结构
   >     2. 缺点：存储较小的对象时指针占用比例高；不支持随机访问，访问效率较低
   >     3. 适用场景：存储大对象、数据量大的场景；
   >  3. 
   >
   >