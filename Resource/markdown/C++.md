# C++基础

1. 链表和数组之间的区别

   > 1.结构
   >
   > 2.内存
   >
   > 3.长度
   >
   > 4.访问效率
   > 5.增删效率
   >
   > 6.应用场景

2. map

   > 1.性质：关联式容器
   >
   > 2.底层实现
   >
   > 3.TODO

3. 红黑树和普通二叉树的区别

   > 1.TODO

4. static

   > 1. 总结：静态变量拥有全局变量的生命期，但只能作用于自己的作用域
   > 2. 静态成员变量（面向对象）
   >    1. 类关联变量，类内所有实例共享
   >    2. 受到访问权限的限定
   >    3. 存储在全局数据区，不占用对像内存，因此使用sizeof不计算静态成员的大小
   >    4. 必须初始化
   > 3. 静态成员函数（面向对象）
   >    1. 类关联函数，类内所有实例共享
   >    2. 受到访问权限的限定
   >    3. 无this指针，即不关联具体实例，因此不能访问非静态成员
   > 4. 静态全局变量（面向过程）
   >    1. 全局变量前添加static
   >    2. 全局数据区存储
   >    3. 自动初始化为0
   >    4. 静态全局变量作用域转变为文件作用域，即本文件可见，其他文件不可见；因此可以在其他文件中存在同名变量
   > 5. 静态局部变量（面向过程）
   >    1. 首次执行声明语句进行初始化，后续不再
   >    2. 没有显示初始化时则自动初始化为0
   >    3. 延长生命周期，由局部转为全局
   > 6. 静态函数（面向过程）
   >    1. 转变为文件作用域，其他文件不可见，因此可以在其他文件中存在同名函数

5. 函数指针与指针函数

   > | 区别点 | 指针函数                         | 函数指针                 |
   > | ------ | -------------------------------- | ------------------------ |
   > | 本质   | 函数。返回值是某一类型指针的函数 | 指针。指向函数的指针变量 |
   > | 形式   | TYPE* func(ARGS...)              | TYPE  (*func)(ARGS)      |

6. break continue

   > 1. 作用：更改程序的执行流程
   > 2. 区别：break直接退出循环体或switch判断；而continue跳出循环中某次执行，跳转到判断语句

7. malloc 和 new的区别

   > | 区别点                   | malloc              | new            |
   > | ------------------------ | ------------------- | -------------- |
   > | 性质                     | C标准库的函数       | C++关键字      |
   > | 是否需要显式给出内存大小 | 是                  | 否             |
   > | 返回值                   | void*，手动进行转换 | 指定类型的指针 |
   > | 失败行为                 | NULL                | bad_alloc      |
   > | 申请来源                 | 堆区                | 自由存储区     |
   > | 是否允许重载             | 否                  | 是             |
   > | 是否会调用构造           | 否                  | 是             |
   > | 是否类型安全             | 否                  | 是             |

8. C++虚函数和纯虚函数

   > | 区别点           | 虚函数                      | 纯虚函数                     |
   > | ---------------- | --------------------------- | ---------------------------- |
   > | 形式             |                             | 函数末尾有=0                 |
   > | 基类是否实现     | 必须实现                    | 可有可无                     |
   > | 子类是否override | 可overrider，也可不override | 若子类非抽象类则必须override |
   > |                  |                             |                              |
   > |                  |                             |                              |

9. C++ 纯虚函数的目的

   > 1. 提供一个可被派生类改写的接口，形成通用语义和规范
   > 2. 有些类在逻辑上而言就是抽象的、概念的，是不应当生成实例的（如动物），因此需要纯虚函数将该类转换为抽象类，避免其实例化

10. 指针和引用的区别

    > | 区别点               | 指针                              | 引用              |
    > | -------------------- | --------------------------------- | ----------------- |
    > | 性质                 | 存储变量地址的变量                | 变量的别名        |
    > | 定义时是否需要初始化 | 否                                | 是                |
    > | 是否可为空           | 是                                | 否                |
    > | 是否可变             | 可变                              | 不可变            |
    > | sizeof               | 指针大小                          | 变量的大小        |
    > | 是否可以嵌套/多级    | 是                                | 否                |
    > | 自增/减              | 指向下一个/上一个同类型变量的指针 | 变量自身的自增/减 |

11. 用户态 内核态

    > 1. 用户态：高保护级别的状态，此时只能执行一些一般指令，而不能执行一些直接操作硬件的高级指令。
    >    用户态使用用户栈运行；用户态只能访问地址空间中的低3G空间
    > 2. 内核态：低保护级别状态，该状态下可以执行任意指令、操作任意计算机资源。
    >    内核态似乎用内核栈运行；内核态可以访问全部的4G地址空间
    > 3. 当用户需要使用硬件资源的时候，需要通过系统调用来进入内核状态，进而去完成硬件操作。通常一次系统调用的流程为：

12. 虚拟内存是如何实现的？

    > 1. 虚拟内存的作用：假设没有虚拟内存，应用层的程序员写程序还需要考虑程序内存的起止位置、不同程序内存地址冲突和内存回收利用等复杂的问题，降低了开发效率，因此加入虚拟内存这样一个中间层，将内存管理的细节转入到操作系统中，对应用层程序员只提供简单的一些接口，隐藏了繁杂的内存管理细节
    > 2. 虚拟内存：对每个进程抽象一个地址连续的虚拟内存空间，进程代码中的所有地址都是指的该空间中的地址，应用层程序员就只需要考虑在虚拟内存中如何使用内存即可；
    >    而在操作系统层面，内核将上层使用的虚拟地址映射到物理内存地址中并加以管理。
    >    虚拟内存最核心的部分就是如何将虚拟地址映射到物理地址上
    > 3. 映射手段
    >    1. 分段
    >       1. 模型
    >       2. 核心机制
    >       3. 问题
    >    2. 分页
    >       1. 模型
    >       2. 核心机制
    >       3. 问题
    >    3. 段页式
    
13. 重载(overload)、重写(override)、隐藏(overwrite)

    > 1. 重载：
    >    1. 编译时多态
    >    2. 同作用域内同名不同参数列表的一系列函数
    >    3. 调用时根据参数列表选择函数
    > 2. 重写：
    >    1. 运行时多态
    >    2. 派生类中与基类虚函数同名、同参数列表、同返回值的函数
    >    3. 调用时根据指针的实际类型选择函数
    > 3. 隐藏
    >    1. 派生类与基类非虚函数同名，导致派生类屏蔽了基类的函数

14. 全局变量的初始化时机

    > 1. 在main函数之前完成初始化
    > 2. 细分
    >    1. 静态初始化
    >       编译时完成。常量初始化的简单变量
    >    2. 动态初始化
    >       运行时完成。需要函数初始化或者复杂类型需要构造函数初始化

15. #ifdef #endif

    > 1. 条件编译。满足条件时执行一段代码，不满足条件时执行令一段代码
    > 2. 防止头文件重定义。

16. #ifdef、#if

    > 1. #ifdef知识判断后面的符号是否已经定义，而不在乎符号的值；#if需要判断其后表达式的值，表达式为真才进入其所在的分支
    > 2. #ifdef只能搭配#else使用，不能搭配#elif，即只能为双分支；#if可以搭配#elif实现多分支
    > 3. #ifdef和#if都需要以#endif作为结尾

17. 如何判断大小端

    > 1. 强制类型转换
    >
    >    ```
    >    int a = 0x1234;
    >    char c = (char)(a);
    >    if (c == 0x12)	// 高位字节位于低地址
    >        cout << "big endian" << endl;
    >    else if(c == 0x34) // 低位字节位于低地址
    >        cout << "little endian" << endl;
    >    ```
    >
    > 2. 联合体union
    >
    >    ```
    >    union endian
    >    {
    >        int a;
    >        char c;
    >    };
    >
    >    endian value;
    >    value.a = 0x1234;
    >
    >    if (value.c == 0x12)	// 高位字节位于低地址
    >        cout << "big endian" << endl;
    >    else if(value.c == 0x34) // 低位字节位于低地址
    >        cout << "little endian" << endl;
    >    ```

18. override

    >1. 作用：让编译器检查派生类中覆盖的函数是否与父类中的虚函数签名一直，不一致时会报错

19. 类、结构体

    > | 区别点       | 类      | 结构体 |
    > | ------------ | ------- | ------ |
    > | 默认访问权限 | private | public |
    > | 默认继承     | private | public |

20. 变量的声明和定义

    > 1. 定义创建了变量，并为其分配了内存；声明表明了变量的类型和名字，但不分配内存
    > 2. 变量在程序内只能够定义一次，但可以多次声明
    > 3. eg：
    >    1. 定义：int a = 1；
    >    2. 声明：extern int a；

21. inline

    > 1. 对编译器的一种请求，编译器可能拒绝
    > 2. inline函数的机制：将编译后的函数体直接插入到调用处，避免了跳转、压栈等操作的开销
    > 3. inline是一种特殊的函数，会进行类型检查
    > 4. 编译限制
    >    1. 函数体内不能有循环体
    >    2. 函数体内不能有过多的分支
    >    3. 函数体不能过于庞大
    >    4. 声明必须在调用前

22. auto

    > 1. 必须初始化，否则无法推导类型
    > 2. 一行多个变量时，不能有二义性
    > 3. 不能用作函数参数类型
    > 4. 不能用于非静态成员变量
    > 5. 不能定义数组，但可以定义指针
    > 6. 无法推导模板参数
    > 7. 不声明为引用或指针时，auto会忽略赋值号右边的应用类型和cv限定；反之，则保留

23. 三大特性

    > 1.  封装：隐藏对象的属性和实现细节，对外界仅暴露特定的访问、交互接口
    > 2. 继承：某种类的对象复用另一种类的对象的属性和方法，减少了代码冗余
    > 3. 多态：一种事物表现出不同事物特性的能力。在C++中表现为能够将子类的实例赋值给父类的指针
    
24. 浅拷贝和深拷贝的区别

    > 1. 深浅拷贝是针对含有指针成员的对象而言的
    > 2. 假设类Class内含有一个指针成员P。
    >    现在有两个实例A，B，其中B利用A进行初始化，调用了拷贝构造函数。
    >    1. 浅拷贝：实例A中的指针成员$P_A$和实例B中的指针成员$P_B$指向同一块内存M，则进行析构的时候，内存M就会被析构两次，造成错误
    >    2. 深拷贝：实例B在拷贝构造函数中为指针成员$P_B$申请新的内存空间$M_B$，并将$P_A$所指向内存的内容拷贝进来，这样，A、B析构时释放不同的内存空间，就不会产生错误

25. C++程序内存分区

    > 1. 堆区
    > 2. 栈区
    > 3. 全局/静态数据区[^1]
    >    1. bss：未初始化的全局变量
    >    2. data：编译阶段就能确定的数据——已初始化的全局变量、静态变量、常量
    > 4. 代码区



[^5]:[浅谈程序中的text段、data段和bss段](https://zhuanlan.zhihu.com/p/28659560#:~:text=%20bss%E4%B8%8D%E5%8D%A0%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%85%B6%E5%86%85%E5%AE%B9%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E6%B8%85%E9%9B%B6%EF%BC%89%EF%BC%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E8%87%AA%E8%A1%8C%E6%89%8B%E5%8A%A8%E6%B8%85%E9%9B%B6%E3%80%82%20%E8%80%8Cdata%E6%AE%B5%E5%88%99%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%85%B6%E5%86%85%E5%AE%B9%E7%94%B1%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%80%A0%E6%88%90%E4%BA%86%E4%B8%8A%E8%BF%B0%E6%83%85%E5%86%B5%E3%80%82,bss%E6%AE%B5%EF%BC%88%E6%9C%AA%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89%E5%B9%B6%E4%B8%8D%E7%BB%99%E8%AF%A5%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%8F%AA%E6%98%AF%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E6%89%80%E9%9C%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%20data%E6%AE%B5%EF%BC%88%E5%B7%B2%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%AD%E3%80%82%20data%E6%AE%B5%E5%8C%85%E5%90%AB%E7%BB%8F%E8%BF%87%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%80%BC%E3%80%82)